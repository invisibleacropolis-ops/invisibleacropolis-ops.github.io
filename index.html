<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Nebula Galaxy</title>
    <style>
        /* Modern CSS Reset */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #ui {
            position: absolute;
            bottom: 30px; left: 30px;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 10;
        }
        #webgl-fallback {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: radial-gradient(circle at top, rgba(27, 57, 132, 0.35), rgba(0, 0, 0, 0.95));
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 1px;
            z-index: 20;
        }
        #webgl-fallback h1 {
            font-weight: 200;
            font-size: 1.3rem;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        #webgl-fallback p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }
        h1 { font-weight: 200; font-size: 1.2rem; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; }
        p { font-size: 0.8rem; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <div id="ui">
        <h1>Nebula Engine v3.0</h1>
        <p>Advanced Fly Controls • Shake • Speed • Tracking</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        camera.position.set(4, 2, 5);

        const supportsWebgl = (() => {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext('webgl2') || canvas.getContext('webgl'));
        })();

        if (!supportsWebgl) {
            const fallback = document.createElement('div');
            fallback.id = 'webgl-fallback';
            fallback.innerHTML = `
                <h1>WebGL not supported on this device.</h1>
                <p>Please try a modern browser or a device with WebGL enabled.</p>
            `;
            document.body.appendChild(fallback);
        } else {
            const init = () => {
                const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setClearColor(0x000000);
                document.body.appendChild(renderer.domElement);

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;

                // --- 2. GALAXY GENERATOR ---
                const parameters = {
                    count: 60000,
                    size: 0.015,
                    radius: 5,
                    branches: 3,
                    spin: 1,
                    randomness: 0.2,
                    randomnessPower: 3,
                    insideColor: '#ff6030',
                    outsideColor: '#1b3984',
                    autoPerformance: true,
                };

                let geometry = null;
                let material = null;
                let points = null;

                const generateGalaxy = () => {
                    if (points !== null) {
                        geometry.dispose();
                        material.dispose();
                        scene.remove(points);
                    }

                    geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(parameters.count * 3);
                    const colors = new Float32Array(parameters.count * 3);

                    const colorInside = new THREE.Color(parameters.insideColor);
                    const colorOutside = new THREE.Color(parameters.outsideColor);

                    for (let i = 0; i < parameters.count; i++) {
                        const i3 = i * 3;
                        const radius = Math.random() * parameters.radius;
                        const spinAngle = radius * parameters.spin;
                        const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2;

                        const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                        const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                        const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;

                        positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                        positions[i3 + 1] = randomY;
                        positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                        const mixedColor = colorInside.clone();
                        mixedColor.lerp(colorOutside, radius / parameters.radius);

                        colors[i3] = mixedColor.r;
                        colors[i3 + 1] = mixedColor.g;
                        colors[i3 + 2] = mixedColor.b;
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                    material = new THREE.PointsMaterial({
                        size: parameters.size,
                        sizeAttenuation: true,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending,
                        vertexColors: true
                    });

                    points = new THREE.Points(geometry, material);
                    scene.add(points);
                };

                generateGalaxy();

                // --- 3. POST PROCESSING (BLOOM) ---
                const renderScene = new RenderPass(scene, camera);
                
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.5; 
                bloomPass.radius = 0;

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // --- 4. CINEMATIC CAMERA STATE ---
                const cineState = {
                    active: false,
                    speed: 0.2,
                    distance: 6.0,
                    shake: 0.2,     // "Camera Variation"
                    focusWander: 1.0, // "Tracking" looseness
                    rotationSpeed: 0.05
                };

                // --- 5. GUI ---
                const gui = new GUI();
                
                // Galaxy Folder
                const folderGalaxy = gui.addFolder('Galaxy Structure');
                folderGalaxy.add(parameters, 'count').min(1000).max(100000).step(100).onFinishChange(generateGalaxy);
                folderGalaxy.add(parameters, 'radius').min(0.01).max(20).step(0.01).onFinishChange(generateGalaxy);
                folderGalaxy.add(parameters, 'branches').min(2).max(20).step(1).onFinishChange(generateGalaxy);
                folderGalaxy.add(parameters, 'randomness').min(0).max(2).step(0.001).onFinishChange(generateGalaxy);
                folderGalaxy.addColor(parameters, 'insideColor').onFinishChange(generateGalaxy);
                folderGalaxy.addColor(parameters, 'outsideColor').onFinishChange(generateGalaxy);

                // Performance Folder
                const folderPerformance = gui.addFolder('Performance');
                folderPerformance.add(parameters, 'autoPerformance').name('Auto Performance');

                // Bloom Folder
                const folderBloom = gui.addFolder('Bloom FX');
                folderBloom.add(bloomPass, 'strength').min(0).max(3).step(0.01).name('Intensity');
                folderBloom.add(bloomPass, 'radius').min(0).max(1).step(0.01).name('Radius');
                folderBloom.add(bloomPass, 'threshold').min(0).max(1).step(0.01).name('Threshold');

                // Cinematic Folder
                const folderCine = gui.addFolder('Cinematic Fly Thru');
                folderCine.add(cineState, 'active').name('Enable Fly Mode');
                folderCine.add(cineState, 'speed').min(0.01).max(2.0).name('Fly Speed');
                folderCine.add(cineState, 'distance').min(1).max(15).name('Orbit Distance');
                folderCine.add(cineState, 'shake').min(0).max(2).name('Camera Shake');
                folderCine.add(cineState, 'focusWander').min(0).max(5).name('Focus Drift');
                folderCine.add(cineState, 'rotationSpeed').min(0).max(0.5).step(0.01).name('Galaxy Spin');

                // --- 6. ANIMATION LOOP ---
                const clock = new THREE.Clock();
                const performanceTuning = {
                    highFrameTimeMs: 40,
                    lowFrameTimeMs: 25,
                    minCount: 1000,
                    maxCount: 100000,
                    decreaseRatio: 0.9,
                    increaseRatio: 1.05,
                    frameWindow: 60,
                    adjustmentCooldownFrames: 45,
                };
                const frameTimeSamples = [];
                let frameTimeSum = 0;
                let cooldownFrames = 0;
                
                const tick = () => {
                    const deltaTime = clock.getDelta();
                    const elapsedTime = clock.elapsedTime;
                    const frameTimeMs = deltaTime * 1000;

                    // Track rolling average frame time for adaptive performance tuning.
                    frameTimeSamples.push(frameTimeMs);
                    frameTimeSum += frameTimeMs;
                    if (frameTimeSamples.length > performanceTuning.frameWindow) {
                        frameTimeSum -= frameTimeSamples.shift();
                    }

                    // 1. Rotate Galaxy
                    points.rotation.y = elapsedTime * cineState.rotationSpeed;

                    // 2. Camera Logic
                    if(cineState.active) {
                        controls.enabled = false;
                        
                        // Base Orbit (The smooth path)
                        // We multiply time by speed
                        const t = elapsedTime * cineState.speed;
                        
                        // Calculate Base Position
                        // We use sine/cosine for a smooth loop, multiplied by distance
                        let camX = Math.cos(t) * cineState.distance;
                        let camZ = Math.sin(t) * cineState.distance;
                        // Vertical movement (bobbing up and down)
                        let camY = Math.sin(t * 0.5) * (cineState.distance * 0.4);

                        // Add "Camera Shake" / Variation
                        // We use higher frequency sine waves to simulate turbulence
                        camX += Math.sin(elapsedTime * 2.5) * cineState.shake;
                        camY += Math.cos(elapsedTime * 3.0) * cineState.shake;
                        camZ += Math.sin(elapsedTime * 2.0) * cineState.shake;

                        camera.position.set(camX, camY, camZ);
                        
                        // Smart Tracking / Focus Drift
                        // Instead of looking strictly at 0,0,0, we look at a moving point near the center
                        const focusX = Math.sin(elapsedTime * 0.3) * cineState.focusWander;
                        const focusY = Math.cos(elapsedTime * 0.5) * cineState.focusWander;
                        const focusZ = Math.sin(elapsedTime * 0.4) * cineState.focusWander;

                        camera.lookAt(focusX, focusY, focusZ);

                    } else {
                        controls.enabled = true;
                        controls.update();
                    }

                    // 3. Render
                    composer.render();

                    // 4. Adaptive performance: reduce or raise star count based on frame time.
                    if (parameters.autoPerformance && frameTimeSamples.length > 0) {
                        const averageFrameTime = frameTimeSum / frameTimeSamples.length;
                        if (cooldownFrames > 0) {
                            cooldownFrames -= 1;
                        } else if (averageFrameTime > performanceTuning.highFrameTimeMs) {
                            const reducedCount = Math.max(
                                performanceTuning.minCount,
                                Math.round((parameters.count * performanceTuning.decreaseRatio) / 100) * 100
                            );
                            if (reducedCount < parameters.count) {
                                parameters.count = reducedCount;
                                generateGalaxy();
                                cooldownFrames = performanceTuning.adjustmentCooldownFrames;
                            }
                        } else if (averageFrameTime < performanceTuning.lowFrameTimeMs) {
                            const increasedCount = Math.min(
                                performanceTuning.maxCount,
                                Math.round((parameters.count * performanceTuning.increaseRatio) / 100) * 100
                            );
                            if (increasedCount > parameters.count) {
                                parameters.count = increasedCount;
                                generateGalaxy();
                                cooldownFrames = performanceTuning.adjustmentCooldownFrames;
                            }
                        }
                    }
                    
                    window.requestAnimationFrame(tick);
                }

                tick();

                // Handle Resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                });
            };

            init();
        }
    </script>
</body>
</html>
