<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Reactive Spectrum Sculpt</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: radial-gradient(circle at top, rgba(15, 20, 35, 0.95), rgba(0, 0, 0, 0.98));
            color: rgba(255, 255, 255, 0.85);
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 18px;
            left: 18px;
            z-index: 10;
            max-width: 340px;
            background: rgba(10, 12, 20, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 14px 16px;
            backdrop-filter: blur(10px);
        }
        #ui h1 {
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 300;
            margin-bottom: 8px;
        }
        #ui p {
            font-size: 0.78rem;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.65);
            margin-bottom: 10px;
        }
        #audio-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.75rem;
        }
        #audio-controls label {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        #audio-controls input[type="file"] {
            font-size: 0.75rem;
        }
        #audio-controls button {
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.75rem;
            transition: background 0.2s ease, border 0.2s ease;
        }
        #audio-controls button:hover {
            background: rgba(255, 255, 255, 0.16);
            border-color: rgba(255, 255, 255, 0.3);
        }
        #status {
            font-size: 0.72rem;
            color: rgba(255, 255, 255, 0.55);
        }
        #webgl-fallback {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: radial-gradient(circle at top, rgba(27, 57, 132, 0.35), rgba(0, 0, 0, 0.95));
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 1px;
            z-index: 20;
        }
        #webgl-fallback h1 {
            font-weight: 200;
            font-size: 1.3rem;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        #webgl-fallback p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="ui">
        <h1>Audio Reactive Sculpt</h1>
        <p>
            Feed in a song or microphone input. FFT bins drive instanced geometry scale,
            color glow, and displacement. Use the GUI to switch modes and tune sensitivity.
        </p>
        <div id="audio-controls">
            <label>
                Load audio file
                <input id="file-input" type="file" accept="audio/*">
            </label>
            <button id="mic-button" type="button">Enable Microphone</button>
            <div id="status">Status: Waiting for audio source.</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js';

        const supportsWebgl = (() => {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext('webgl2') || canvas.getContext('webgl'));
        })();

        if (!supportsWebgl) {
            const fallback = document.createElement('div');
            fallback.id = 'webgl-fallback';
            fallback.innerHTML = `
                <h1>WebGL not supported on this device.</h1>
                <p>Please try a modern browser or a device with WebGL enabled.</p>
            `;
            document.body.appendChild(fallback);
        } else {
            // --- Scene setup ---
            const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x04050a, 1);
            document.body.appendChild(renderer.domElement);

            const scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x02030a, 8, 30);

            const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(6, 5, 8);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0x6677ff, 0.35));
            const keyLight = new THREE.PointLight(0x88ccff, 1.2, 40);
            keyLight.position.set(6, 10, 6);
            scene.add(keyLight);

            // --- Audio analysis setup ---
            const audioState = {
                context: null,
                analyser: null,
                sourceNode: null,
                mediaElement: null,
                dataArray: null,
                smoothing: 0.8,
                fftSize: 1024,
                currentSource: 'None'
            };

            const statusEl = document.getElementById('status');
            const fileInput = document.getElementById('file-input');
            const micButton = document.getElementById('mic-button');

            const updateStatus = (message) => {
                statusEl.textContent = `Status: ${message}`;
            };

            const ensureAudioContext = async () => {
                if (!audioState.context) {
                    audioState.context = new AudioContext();
                }
                if (audioState.context.state === 'suspended') {
                    await audioState.context.resume();
                }
                if (!audioState.analyser) {
                    audioState.analyser = audioState.context.createAnalyser();
                    audioState.analyser.fftSize = audioState.fftSize;
                    audioState.analyser.smoothingTimeConstant = audioState.smoothing;
                    audioState.dataArray = new Uint8Array(audioState.analyser.frequencyBinCount);
                }
            };

            const disconnectCurrentSource = () => {
                if (audioState.sourceNode) {
                    audioState.sourceNode.disconnect();
                    audioState.sourceNode = null;
                }
                if (audioState.mediaElement) {
                    audioState.mediaElement.pause();
                    audioState.mediaElement = null;
                }
            };

            const connectSourceNode = (node, { playback = true } = {}) => {
                disconnectCurrentSource();
                audioState.sourceNode = node;
                audioState.sourceNode.connect(audioState.analyser);
                if (playback) {
                    audioState.analyser.connect(audioState.context.destination);
                } else {
                    audioState.analyser.disconnect();
                }
            };

            const handleFileInput = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                await ensureAudioContext();

                const audio = new Audio();
                audio.src = URL.createObjectURL(file);
                audio.loop = true;
                audio.crossOrigin = 'anonymous';
                await audio.play();

                const sourceNode = audioState.context.createMediaElementSource(audio);
                connectSourceNode(sourceNode, { playback: true });
                audioState.mediaElement = audio;
                audioState.currentSource = `File: ${file.name}`;
                updateStatus(`Playing ${file.name}`);
            };

            const handleMicInput = async () => {
                try {
                    await ensureAudioContext();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const sourceNode = audioState.context.createMediaStreamSource(stream);
                    connectSourceNode(sourceNode, { playback: false });
                    audioState.currentSource = 'Microphone';
                    updateStatus('Microphone live');
                } catch (error) {
                    updateStatus('Microphone blocked or unavailable');
                    console.warn('Microphone error:', error);
                }
            };

            fileInput.addEventListener('change', handleFileInput);
            micButton.addEventListener('click', handleMicInput);

            // --- Instanced geometry setup ---
            // We generate a grid of instances. Each instance knows its base position so
            // we can apply audio-driven scale + displacement without reallocating buffers.
            const parameters = {
                gridX: 64,
                gridY: 48,
                spacing: 0.25,
                baseScale: 0.22,
                amplitude: 2.2,
                displacement: 1.8,
                sensitivity: 1.3,
                mode: 'Spectrum Bars',
                colorBoost: 1.2,
                waveSpeed: 1.2
            };

            const totalInstances = parameters.gridX * parameters.gridY;
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                roughness: 0.35,
                metalness: 0.2,
                emissive: new THREE.Color(0x001122)
            });

            const instancedMesh = new THREE.InstancedMesh(geometry, material, totalInstances);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(totalInstances * 3), 3);
            scene.add(instancedMesh);

            const basePositions = [];
            const dummy = new THREE.Object3D();
            const colorA = new THREE.Color('#4aa3ff');
            const colorB = new THREE.Color('#ff4acb');
            const tempColor = new THREE.Color();

            let instanceIndex = 0;
            for (let y = 0; y < parameters.gridY; y++) {
                for (let x = 0; x < parameters.gridX; x++) {
                    const px = (x - parameters.gridX / 2) * parameters.spacing;
                    const py = (y - parameters.gridY / 2) * parameters.spacing;
                    basePositions.push(new THREE.Vector3(px, 0, py));

                    tempColor.copy(colorA).lerp(colorB, y / parameters.gridY);
                    instancedMesh.setColorAt(instanceIndex, tempColor);

                    dummy.position.set(px, 0, py);
                    dummy.scale.setScalar(parameters.baseScale);
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(instanceIndex, dummy.matrix);

                    instanceIndex++;
                }
            }
            instancedMesh.instanceColor.needsUpdate = true;

            // --- GUI controls ---
            const gui = new GUI();
            gui.title('Audio Reactive Controls');
            gui.add(parameters, 'mode', ['Spectrum Bars', 'Radial Ripple', 'Orbit Drift']);
            gui.add(parameters, 'sensitivity', 0.2, 3, 0.1);
            gui.add(parameters, 'amplitude', 0.2, 4, 0.1);
            gui.add(parameters, 'displacement', 0, 4, 0.1);
            gui.add(parameters, 'colorBoost', 0.2, 3, 0.1);
            gui.add(parameters, 'waveSpeed', 0.2, 3, 0.1);

            // --- Animation loop ---
            const clock = new THREE.Clock();

            const getFrequencyValue = (index, binCount) => {
                if (!audioState.analyser) return 0;
                const scaledIndex = Math.floor(index % binCount);
                const value = audioState.dataArray[scaledIndex] / 255;
                return Math.pow(value * parameters.sensitivity, 1.2);
            };

            const updateInstances = (elapsed) => {
                if (audioState.analyser) {
                    audioState.analyser.getByteFrequencyData(audioState.dataArray);
                }

                const binCount = audioState.dataArray ? audioState.dataArray.length : 1;
                const columnOffset = parameters.gridX / 2;
                const rowOffset = parameters.gridY / 2;

                let peakIntensity = 0;

                for (let i = 0; i < totalInstances; i++) {
                    const x = i % parameters.gridX;
                    const y = Math.floor(i / parameters.gridX);
                    const basePosition = basePositions[i];
                    const bandIndex = Math.floor((x / parameters.gridX) * binCount);
                    const bandValue = getFrequencyValue(bandIndex, binCount);

                    let height = bandValue * parameters.amplitude;
                    let displacement = bandValue * parameters.displacement;

                    if (parameters.mode === 'Radial Ripple') {
                        const dx = x - columnOffset;
                        const dy = y - rowOffset;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const wave = Math.sin(distance * 0.45 - elapsed * parameters.waveSpeed);
                        height = (bandValue + wave * 0.5) * parameters.amplitude;
                        displacement = (bandValue + wave) * parameters.displacement;
                    }

                    if (parameters.mode === 'Orbit Drift') {
                        const angle = (x / parameters.gridX) * Math.PI * 2 + elapsed * 0.3;
                        const orbitOffset = Math.sin(angle + y * 0.1) * 0.6;
                        displacement = (bandValue + orbitOffset) * parameters.displacement;
                        height = (bandValue * 0.7 + Math.abs(orbitOffset)) * parameters.amplitude;
                    }

                    const emissiveStrength = Math.min(height * parameters.colorBoost, 2.5);
                    const colorMix = THREE.MathUtils.clamp(height * 0.5, 0, 1);
                    tempColor.copy(colorA).lerp(colorB, colorMix);

                    dummy.position.set(basePosition.x, displacement, basePosition.z);
                    dummy.scale.set(parameters.baseScale, parameters.baseScale + height, parameters.baseScale);
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                    instancedMesh.setColorAt(i, tempColor);
                    if (emissiveStrength > peakIntensity) {
                        peakIntensity = emissiveStrength;
                    }
                }

                material.emissiveIntensity = peakIntensity;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.instanceColor.needsUpdate = true;
            };

            const animate = () => {
                requestAnimationFrame(animate);
                const elapsed = clock.getElapsedTime();
                updateInstances(elapsed);
                controls.update();
                renderer.render(scene, camera);
            };

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
